# Пример: Нахождение неподвижных точек функции

В этот раз мы используем всё, что узнали о функциях высшего порядка. Мы должны найти неподвижные точки функции. Неподвижная точка - это точка, которую заданное отображение приводит в неё же. Иными словами, когда `f(x) = x`.

Например: `f(x) = 1 + x/2` (неподвижная точка - `x=2`)

Для некоторых функций можно найтинеподвижные точки, если начать с начальной `x`, а затем вычислять `f(x)` :

```
x, f(x), f(f(x)), f(f(f(x))), ...
```

Пока значение не перестанет меняться совсем (или не станет меняться на очень маленькую величину.

Например, мы можем написать такой алгоритм:

```scala
def main(arguments: Array[String]) = {
  val point = 1 // стартовое значение
  println( fixedPoint(x => 1+x/2)(point) ) // близко к 2
}

val tolerance = 0.0001
def isCloseEnough(x: Double, y: Double) =
  abs((x-y)/x)/x < tolerance

def fixedPoint(f: Double => Double)(firstGuess: Double) = {
  @tailrec
  def iterate(guess: Double): Double = {
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}
```

## Нахождение квадратного корня

Ранее мы писали алгоритм для нахождения квадратного корня по методу Ньютона. Для этого мы написали несколько функций:

```scala
def sqrtIter(guess: Double, x: Double): Double =
  if (isGoodEnough(guess, x)) guess
  else sqrtIter(improve(guess, x), x)

def isGoodEnough(guess: Double, x: Double) =
	// берем guess и находим квадрат, смотрим на x
	abs(guess * guess - x) < 0.001

def improve(guess: Double, x: Double) =
	(guess + x / guess) / 2

def sqrt(x: Double) = sqrtIter(1.0, x)

print(sqrt(2)) // 1.4142156862745097

```

Здесь мы, по сути, так же проверяли `isGoodEnough`, но вместо рекурсивной `iterate` у нас была внешняя функция `improve`, которую мы вызывали из рекурсивной `sqrtIter`. Можно ли как-то *вывести* последовательность действий, которая была использована?

На самом деле, можно:

Вот определение функции `sqrt`: 

`sqrt(x)` - это такой номер `y`, при котором выполняется равенство `y * y = x`.

Или, если поделить обе стороны выражения на `y`:

`sqrt(x)` - это такой номер, при котором выполняется равенство `y = x/y`

Получается, `sqrt(x)` - это неподвижная точка функции `y = x/y`.

Тогда мы можем использовать нашу функцию для вычисления квадратного корня вот так:

```scala
def sqrt(x: Double) =
  fixedPoint(y => x/y)(1.0)
```

Однако, на самом деле, это не подходит. Попытка вычислить `sqrt(2)` приводит к бесконечному циклу.

Добавим `println` в функцию `fixedPoint`, чтобы наблюдать изменения `guess`.

Получается примерно следующее:

```scala
def iterate(guess: Double): Double = {
  println(guess)
  val next = f(guess)
  if (isCloseEnough(guess, next)) next
  else iterate(next)
}


вывод:
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
...
```

Наше предположение постоянно болтается между 1 и 2. Если попробовать 4, то оно будет болтаться между 1 и 4. Если в определении `sqrt` передавать как `firstGuess` правильное значение (например, sqrt(9) и firstGuess = 3), то функция сработает.

Один из путей решения - не позволять функции слишком разлетаться в значениях. Это делается усреднением успешных значений оригинальной последовательности:

```scala
def sqrt(x: Double) = fixedPoint(y => (y + x / y)/2)(1.0)

sqrt(9)
```

Полученный вывод:
1.0
5.0
3.4
3.023529411764706
3.00009155413138
3.000000001396984

По сути, если мы рашсирим функцию `fixedPoint` - мы найдём ту же функцию, что разработали на прошлой неделе. 


## Возвраты функций

Предыдущие примеры показали как язык становится мощным, когда мы можем передавать функции. Следующие примеры покажут, что **возвраты** функций не менее полезны.

Снова задумаемся о `sqrt`. Мы заметили, что это неподвижная точка функции `y = x/y`. Техника *стабилизации через усреднение* - достаточно обобщенная, чтобы абстрагировать её в собственную функцию:

```scala
def averageDamp(f: Double => Double)(x: Double) = (x + f(x)) / 2
```

Я переписал пример следующим образом:

```scala
def sqrt(x: Double) = 
  // x передался прямо в averageDump, поэтому усреднение функции 
  // считалось только по y, а x было известным.
  fixedPoint( averageDamp(y => x/y) )(1)


val tolerance = 0.0001
def isCloseEnough(x: Double, y: Double) =
  abs((x-y)/x)/x < tolerance

def fixedPoint(f: Double => Double)(firstGuess: Double) = {
  @tailrec
  def iterate(guess: Double): Double = {
    println(guess)
    val next = f(guess)
    if (isCloseEnough(guess, next)) next
    else iterate(next)
  }
  iterate(firstGuess)
}

// функция возвращает функцию с усреднением
def averageDamp(f: Double => Double): Double => Double =
  x => (x + f(x)) / 2
```

Преподаватель написал функцию, которая возвращает значение, а не усредненную функцию:

```scala
def averageDamp(f: Double => Double)(x: Double) = (x + f(x))/2

def sqrt(x: Double) =
  fixedPoint(averageDamp(y => x / y))(1)

```

В сущности, в моём примере `х` передаётся в `averageDamp` как часть функции, а в примере преподавателя - как переменная.

## Выводы:

Функции - это мощные абстракции, которые позволяют определить обобщенные методы для совершения вычислений как явных и именованных элементов в программе.

На этой неделе мы увидели, что эти абстракции можно комбинировать в функциях высшего порядка для получения новых абстракций.

Каждый программист должен продумывать возможности абстрагировать и переиспользовать.

Высокий уровень абстракции не всегда лучшее решение, но знать техники абстракции важно так же, как и использовать их с умом.

