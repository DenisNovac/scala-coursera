# Функции высшего порядка

**Функции высшего порядка** - это важный концепт. Он позволяет передавать функции как аргументы и возвращать их как результат (*first-class values*). Это даёт гибкий путь композировать команды.

Функции, которые оперируют другими функциями называются Функции высшего порядка. 

*Пример:*

Предположим, мы хотим посчитать сумму всех интегеров между a и b. Мы можем напиать функцию вроде такой:

```scala
def sumInts(a: Int, b: Int): Int =
    if (a>b) 0 else a + sumInts(a + 1, b)
```

Но что, если мы хотим взять сумму кубов между a и b? 

```scala
def sumCubes(a: Int, b: Int): Int =
  if (a>b) 0 else cube(a) + sumCubes(a+1, b)
```

А что, если хотим факториалы между a и b? Ну, тут придётся дописать ещё `fact(a)`, но в целом то же самое.

```scala
def sumFactorials(a: Int, b: Int): Int =
  if (a>b) 0 else fact(a) + sumFactorials(a+1, b)
```

Можем ли мы вытащить отсюда *повторяющийся паттерн*? Это можно сделать следующим образом. Определим функцию `sum`, которая принимает параметр `f` типа `Int => Int` (*"int to int"*, как сказал лектор) и два параметра `a` и `b`. Затем мы прописываем то же, что и раньше:

```scala
def sum(f: Int => Int, a: Int, b: Int): Int =
  if (a>b) 0
  else f(a) + sum(f, a+1, b)
```

Новая вещь здесь - это то, что *`f` - это параметр, в котором передана некоторая функция*. Это не заданная функция заранее, это *параметр*. Тогда мы можем тупо передавать в неё всё необходимое, а предыдущие функции обобщить так, чтобы они выполняли лишь свои действия:

```scala
def id(x: Int): Int = x
def cube(x: Int): Int = x * x * x
def fact(x: Int): Int = if (x == 0) 1 else fact(x - 1)

def sumInts(a: Int, b: Int) = sum(id, a, b)
def sumCubes(a: Int, b: Int) = sum(cube, a, b)
def sumFactorials(a: Int, b: Int) = sum(fact, a, b)
```

## Function Types (Функциональный тип)

Новая вещь здесь - это **Функциональный тип**. Он пишется как `A => B`, где `A` и `B` - это типы. Функция принимает тип `A` и возвращает тип `B`. В таком случае `Int => Int` - это тип функции, которая принимает **маппит** целочисленные к целочисленным.

## Анонимные функции

В предыдущем примере есть проблема. Мы сократили функции, но есть грустная деталь. Мы должны именовать и определять все дополнительные функции, которые используем:

```scala
def id(x: Int): Int = x
def cube(x: Int): Int = x * x * x
def fact(x: Int): Int = if (x == 0) 1 else fact(x - 1)
```

А вот со строками мы можем делать просто `print("hello")`. На самом деле, мы можем делать так с функциями. Такие функции называются **Анонимными**.

```scala
(x: Int) => x * x * x
```

В этом примере у функции есть только параметр и тело. Тип параметра можно опустить, если компилятор может выяснить его из контекста:

```scala
(x: Int, y: Int) => x + y
```

Анонимные функции можно определять и через `def`: 

```scala
(x: T1 ... y: T2) => E
```

```scala
def f(x: T1 ... y: T2) = E;f // в конце нужна ссылка на функцию, которую только что определили
```

При этом `f` это дополнительное имя, которое ещё не было использовано в программе. Иногда имя можно написать вот так, чтобы его ни с чем не перепутали:

```scala
{def f(x: T1 ... y: T2) = E;f} // но обычно так не пишут, хотя это более фундаментальный способ
```

- Поэтому некоторые говорят, что анонимные функции - это такой синтаксический сахар.

Теперь можно переписать наши функции сверху:

```scala
def sum(f: Int => Int, a: Int, b: Int): Int =
  if (a>b) 0
  else f(a) + sum(f, a+1, b)

def sumInts(a: Int, b: Int) = sum(x => x, a, b)
def sumCubes(a: Int, b: Int) = su,(x => x * x * x, a, b)
```

## Упражнение

Написать хвостовую рекурсию, заменив ???:

```scala
def sum(f: Int => Int)(a: Int, b: Int): Int = {
  def loop(a: Int, acc: Int): Int = {
    if (???) ???
    else loop(???, ???)
  }
  loop(???, ???)
}
```

Кстати, в отличие от факториала, эта функция действительно выиграет от хвостовой рекурсии потому что если интервал между `a` и `b` будет велик - рекурсивный обход будет расти экспоненциально.

Результат:

```scala
def sum(f: Int => Int, a: Int, b: Int): Int = {
  @tailrec
  def loop(a: Int, acc: Int): Int = {
    if (a > b) acc
    else loop(a+1, f(a)+acc)
  }
  loop(a, 0)
}
```

