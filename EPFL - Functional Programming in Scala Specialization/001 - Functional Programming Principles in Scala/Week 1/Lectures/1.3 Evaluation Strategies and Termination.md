# 1.3

Стратегии CBN и CBV упрощают выражение к одному и тому же значению, если вычисления конечны. Вызов по значению сначала считает аргументы, а вызов по имени - сначала заменяет функцию и по очереди заменяет аргументы.

Но что, если конечность не гарантированна?

- Если CBV вычисления выражения *e* конечны, тогда и CBN вычисления *e* конечны;
- Обратное не верно.

Пример. Выражение конечно при вычислении по имени, но не при вычислении по значению.

```scala



def first(x: Int, y: Int) = x

first(1, loop)

```

Это выражение вычислимо только по CBN (loop ведь не используется). В CBV loop будет приводиться сам к себе.

## Scala

Мы обычно используем CBV. Обычно такой способ экспоненциально намного эффективнее, чем CBN потому что не вычислят одно и то же много раз.

CBN вызывается так: `=>`.

Пример:

```scala
def loop: Int = loop
def constOne(x: Int, y: => Int) = 1

constOne(1+2, loop) // выполнится успешно

constOne(loop, 1+2) // бесконечный цикл

```











