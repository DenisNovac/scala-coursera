# Согласованность в конечном счёте

> *Согласованность в конечном счёте (англ. eventual consistency) — одна из моделей согласованности, используемая в распределённых системах для достижения высокой доступности, в рамках которой гарантируется, что в отсутствии изменений данных, через какой-то промежуток времени после последнего обновления («в конечном счёте») все запросы будут возвращать последнее обновлённое значение.*

Мы заметили, что в кластере всё постоянно требует времени. Требуется время на подсоединение к кластеру, на одобрение всеми членами. Это происходит немгновенно.

Сильная согласованность:

```scala
private var field = 0
def update(f: Int => Int): Int = synchronized {
  field = f(field)
  field
}
def read(): Int = synchronized{ field }
```

После апдайта все вызовы read будут возвращать обновлённое значение.

Но это блокирует потоки и невозможно в распределённых системах. Конечно, мы можем перенести synchronized в Future (слабая согласованность). Но update будет возвращать уже Future. Будет несколько read, которые не вернут ничего (окно несогласованности).

Eventual consistency - это особый тип слабой согласованности. В ней возможность получить объект происходит в моменты, когда команды на апдейт закончились.

Предположим, несколько акторов хотят получать какие-то значения (поле `field`). Апдейт может произойти на любом из пиров, но в конечном счёте будет виден на всех копиях.


```scala
case class Update(x: Int)
case object Get
case class Result(x: Int)

/** Если апдейт произошёл в нескольких местах - нужно решить, какое поле хранить в итоге */
case class Sync(x: Int, timestamp: Long)


case object Hello

class DistributedStore extends Actor {
  var peers: List[ActorRef] = Nil
  var field = 0
  var lastUpdate = System.currentTimeMillis()

  def receive = {
    case Update(x) =>
      field = x
      lastUpdate = System.currentTimeMillis()
      peers foreach (_ ! Sync(field, lastUpdate))
    
    case Get => sender ! Result(field)

    case Sync(x, timestamp) if timestamp > lastUpdate =>
      field = x
      lastUpdate = timestamp

    case Hello =>
      peers ::= sender
      sender ! Sync(field, lastUpdate)
  }
}
```

## Акторы и согласованность

Взаимодействующие акторы могут быть согласованы только *в конечном счёте*. Это не происходит автоматически и требуется производить вручную. Кластеры решают подобную проблему для поддержания списка актуальных членов кластера - через gossip-сообщения раз в какое-то интервал и hearbeat-проверки соседей. 

Есть специальные классы данных - CRDT - для поддержания согласованности в конечном счете.