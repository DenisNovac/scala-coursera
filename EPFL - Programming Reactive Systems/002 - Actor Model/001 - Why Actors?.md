# Почему акторы?

Мы поговорим о том, как акторы создают другие акторы, как меняют поведение и как обмениваются сообщениями. 

Первое коммерческое использование нашли в Erlang в 1995.

2009 - создание Akka.

Akka - Actor фреймворк на JVM для Java и Scala.

## Проблемы

### Потоки

В прошлом программы становились быстрее за счёт развития технологий и CPU в частности. 

Сегодня CPU не становятся быстрее, но становятся шире:

- Несколько ядер с разделяемой памятью;
- Виртуальные ядра с разделяемым физическим ядром.

Как получить выгоду:

- Запускать несколько программ (мульти-таскинг);
- Запускать части одной программы в разных потоках (мульти-трединг).

### Многопоточность

Мультитрединг должен поддерживаться программой особыми приемами. Например, нужно учитывать, что треды должны как-то синхронизировать свои действия. 

Простейший пример: банковский аккаунт. Если счёт не синхронизирован, то есть шанс добавить и убавить от него так, что одна из операций проигнорируется:

- Есть счёт - 100;
- Зачисляем 10 (стало 110) и снимаем 50 (должно стать 60) почти одновременно;
- В итоге получили 50 потому что операция "снять 50" началась на 100 и закончилась позже зачисления 10. 

Как это починить? Синхронизировать баланс. Все разделяемые состояния должны быть защищены (заблокированы во время работы одного из тредов).

Традиционные приёмы: lock, mutex, semaphore.

В Scala любой объект имеет lock: `obj.synchronized{ ... }`. Код будет выполнен защищенным. Например, внутри объекта можно вызывать функции таким образом:

```scala

class BankAccount {
  def deposit(amount: Int): Unit = this.synchronized {
    // ...
  }

  def withdraw(amount: Int): Int = this.synchronized {
    // ...
  }
}
```


Другая проблема может возникнуть, если мы переводим между аккаунтами деньги. Например, есть два банковских аккаунта. При попытке перевода денег они блокируются. А что, если оба пользователя захотят одновременно перевести деньги друг другу?

```scala
transfer(account A, account B)
transfer(account B, account A)
```

Первый метод блокирует account A и идёт блокировать account B. Но тот уже заблокирован вторым методом, который ожидает account A, заблоикрованный первым. Каждый из тредов заблокирован другим. Мы получили Dead-lock.

Решения для таких ситуаций существуют, но они сложны и увеличивают расходы на написание кода.

## Неблокируемые объекты

Мы хотим использовать что-то без блокировок:

- Блокирование может вызывать дедлоки;
- Блокирование плохо для CPU-утилизации;
- Синхронное выполнение связывает отправителя и получателя.
