# Пары и кортежи

Мы посмотрим на взаимодействие с листами, используя новые структуры данных - пары и кортежи. Вы увидите, как пары и кортежи могут помочь в композиции и декомпозиции программы.

## Sorting lists faster

Мы продемонстрируем материалы в этой лекции на примере функции, сортирующей листы. При этом, мы хотим, чтобы она сортировала листы быстрее, чем сортировка вставками. Хороший алгоритм для этого - это *merge sort* (Сортировка слиянием). 

Идея следующая: если лист содержит ноль или один элемент - считаем его отсорированным. Иначе:

- Разделить лист на два подлиста, каждый содержит по половине элементов;
- Отсортировать два подлиста;
- Соединить два сортированных подлиста в один сортированный.

Начнём с этого:

```scala
def msort(xs: List[Int]): List[Int] = {
  val n = xs.length/2
  if (n == 0) xs
  else {
      def merge(xs: List[Int], ys: List[Int]) = ???
      val (fst, snd) = xs splitAt n
      merge(msort(fst), msort(snd))
  }
}
```

Метод merge:

```scala
def merge(xs: List[Int], ys: List[Int]): List[Int] =
  xs match {
    case Nil =>  // левый лист пустой
      ys
    case x :: xs1 =>  // левый лист непустой
      ys match {
        case Nil =>  // правый элемент пустой
          xs
        case y :: ys1 =>  // правый элемент непустой
          if (x < y) x :: merge(xs1, ys)
          else y :: merge(xs, ys1)
      }
  }
```

Метод проходит сначала по левому листу:
- Если он пустой, то merge должен включать все элементы правого листа. 
- Если он непустой, тогда мы идём в правую часть. 
  - Если правая часть пуста - просто возвращаем левую. 
  - Если нет, то мы сравниваем головной элемент каждого листа (x и y)
  - Если x < y, то он должен быть первым (сортировка по возрастанию), а к нему приклеивается остаток xs и весь ys, прошедшие через тот же `merge';
  - То же, но для y >= x.

Работает:

```scala
val l = List(3,4,1,2,4,7,1,0,-2,4,2)
println(msort(l))  // -2, 0, 1, 1, 2, 2, 3, 4, 4, 4, 7 
```


## SplitAt Function

Эта функция возвращает два подлиста: 

- Элементы до n (не включительно);
- Элементы начиная с n;

Листы возвращаются в *паре* (**pair**).


## Пары и кортежи

Пара x и y записывается как (x, y) в Scala.

Пример:

```scala
val pair = ("answer", 42)  // pair: (String, Int) = (answer,42)
```

Пары могут быть использованы для распаковки (pattern binding):

```scala
val (label, value) = pair // label: String = answer  value: Int = 42
```

Аналогично это работает для кортежей с большим количеством элементов.


## Трансляция кортежей

До сих пор все типы, которые мы перечислили в Scala были на деле некоторыми объектами. И кортежи не исключение:

- Кортеж - это параметризованный тип `scala.Tuplen[T1,...Tn]`;
- Выражение кортежа `(e1 ... en)` на деле вызов функции `scala.Tuplen(e1...en)`;
- Получается, что распаковка кортежа это частный случай PM.


Все Tuple*n* классы смоделированы следующим образом:

```scala
case class Tuple2[T1, T2](_1: +T1, _2: +T2) {
  override def toString = "(" + _1 + "," + _2 + ")"
}
```

Видно, что поля кортежа могут быть получны по именам _1 и _2.

Поэтому, вместо паттерн-биндинга (распаковки), можно (но лучше так не делать) писать следующим образом:

```scala
val (label, value) = pair
val label = pair._1
val value = pair._2
```

Распаковка всё же чище и короче, поэтому лучше её.


## Упражнение

Функция `merge` использует вложенное сравнение с образцом. Это не отражает симметрию самого алгоритма `merge`. Перепишите `merge`, используя PM на парах вместо отдельных листов.


```scala
def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {
  case (List(), ys) => ys
  case (xs, List()) => xs
  case (xs, ys) =>
    if (xs.head < ys.head) xs.head :: merge(xs.tail, ys)
    else ys.head :: merge(xs, ys.tail)
}
```

Преподаватель написал так:

```scala
def merge(xs: List[Int], ys: List[Int]): List[Int] = (xs, ys) match {
  case (List(), ys) => ys
  case (xs, List()) => xs
  case (x :: xs1, y :: ys1) =>
    if (x < y) x :: merge(xs1, ys)
    else y :: merge(xs, ys1)
}
```

Это более точный вариант, следует использовать его.

