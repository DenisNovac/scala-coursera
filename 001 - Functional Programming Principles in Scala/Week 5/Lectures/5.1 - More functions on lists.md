# Функции листов

В этой лекции посмотрим больше утильных функций для листов. Мы также узнаем, как они имплементированы на основе фундаментальных операций (head, tail, isEmpty). Посмотрим на элементы:

- `xs.length`;
- `xs.last`;
- `xs.init` - все элементы xs кроме последнего;
- `xs take n` - первые n элементов листа или сам лист, если его длина меньше n;
- `xs drop n` - все элементы, пропуская n первых (остаток после take);
- `xs (n)` - элемент под индексом n.


## Функции создания новых листов:

- `xs ++ ys` лист состоит из элементов xs, за которыми следуют элементы ys.
- `xs.reverse` - лист развёрнут;
- `xs updated (n, x)` - замена в листе элемента с индексом n на элемент x.

```scala
object Main extends App {
  val l = List(1,2,3)
  println(l) // List(1, 2, 3)
  println(l.updated(1,3)) // List(1, 3, 3)
  println(l.updated(0,3)) // List(3, 2, 3)
}
```


## Поиск элементов:

- `xs indexOf x` - индекс первого элемента, эквивалентного x либо -1, если такого не нашлось;
- `xs contains x` - тоже что `xs indexOf x >=0` (проверяет наличие).


## Простота

Как нам известно, методы head и tail достаточно просты - это просто выбор первого элемента и, по сути, второго (это же связный список). А вот что с функцией `last`?

```scala
def last[T](xs: List[T]): T = xs match {
  case List() => throw new Error("last of empty list")
  case List(x) => x
  case y :: ys => last(ys)
}
```

Получается, что поиск последнего элемента занимает время, пропорциональное длине листа xs.


## Упражнение

Написать `init` аналогично `last`:

```scala
def init[T](xs: List[T]): List[T] = xs match {
  case List() => throw new Error("init of empty list")
  case List(x) => Nil  // вместо последнего элемента возвращаем Nil, чем и срезаем его
  case y :: ys => y :: init(ys) // возвратить нужно именно лист, поэтому тут ::
}
```

Тут важен порядок. Рекурсивный вызов init не должен случайно сработать на единичном элементе, но он и не может, т.к. мы точно знаем, что ys - это остаток листа, а это, как минимум, T и Nil. 


# Конкатенация листов

```scala
trait List[+T] {
  def prepend [U >: T](elem: U): List[U] = new Cons(elem. this)
}
```

Склеивание листов похоже на метод `prepend` с прошлой недели, но позволяет добавить не просто элемент, а целый лист. Конкатенация листов осуществляется через `:::`:

```scala
xs ::: ys = ys.:::(xs)
```

Попробуем написать свою функцию для этого:

```scala
def concat[T](xs: Lost[T], ys: List[T]) = ???
```

Раньше мы использовали Pattern Matching для работы с листами. Но здесь их два. Какой из листов нам следует проверять через PM? Ещё можно вспомнить, что когда мы работали с PM, мы составляли листы слева-направо. Тогда мы можем подумать, что будет первым элементом результирующего листа, а что - остатком. Понятно, что при вызове `xs ::: ys` первым элементом будет x из xs, поэтому имеет смысл вызывать PM на нём.

```scala
def concat[T](xs: Lost[T], ys: List[T]) = xs match {
  case List() => ys  // пустой лист плюс ys это ys
  case z :: zs => z :: concat(zs, ys)
}
```

Какова сложность concat? Мы имеем вызов `concat` по каждому элементу xs, пока не дойдем до конца и не прикрепим ссылку на ys. Поэтому она пропорциональна длине xs.

Теперь попробуем имплементировать `reverse`.

Моя попытка:

```scala
def reverse[T](xs: List[T]): List[T] = xs match {
  case List() => Nil
  case y :: ys => reverse(ys).appended(y)
}
```


Код преподавателя:

```scala
def reverse[T](xs: List[T]): List[T] = xs match {
  case List() => xs
  case y :: ys => reverse(ys) ++ List(y)
}
```

Какова сложность reverse? Мы знаем, что `++` линейно и пропорционально длине операнда слева. Плюс мы проходим через каждый элемент. Получается, сложность `n * n`. Это довольно грустная зависимость, позже мы снизим сложность reverse.


## Упражнение

Написать метод, который удалит n-ый элемент листа. Если n за пределами листа - вернуть весь лист.

```scala
def removeAt[T](xs: List[T], n: Int): List[T] = {
  def iter(xs: List[T], n: Int, acc: Int): List[T] = xs match {
    case List() => Nil
    case y :: ys => {
      if (acc == n) iter(ys, n, acc+1)
      else y :: iter(ys, n, acc+1)
    }
  }
  iter(xs, n, 0)
}
```

Преподаватель использовал встроенные методы:

```scala
def removeAt(n: Int, xs: List[Int]) = (xs take n) ::: (xs drop n + 1)
```

`xs take n` - первые n элементов листа или сам лист, если его длина меньше n, а `xs drop n` - все элементы, пропуская n первых (остаток после take); Таким образом, `xs take 5` берёт элементы индексами 0-4, а `xs drop n + 1` - берёт элементы, начиная с 6 индкеса. 