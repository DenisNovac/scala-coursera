# 1.2

Многие элементы этой лекции могут показаться знакомыми, но есть несколько новых. Например, модель вычислений, которую мы называем **substitution model**(модель замен), которая будет очень важна позже. 

REPL - интерактивная строка (Read-Eval-Print Loop).

`sbt console` или `scala` - вызов REPL.

## Вычисления

1. Берётся левый оператор
2. Вычисляются операнды оператора (слева-направо)
3. Применяются операторы к операндам.

Имя вычисляется путём замены его на правую сторону его определения.

Процесс вычисления происходит пока не будет получено значение (например, число).

Пример:

```
pi = 3.14
radius = 10
```

Вычисление:

- `(2 * pi) * radius`
- `(2 * 3.14) * radius`
- `6.28 * radius`
- `6.28 * 10`
- `62.8318`

Определения могут иметь и параметры.

`def square(x: Int) = x * x`

Параметры функций имеют тип, ещё есть возвращаемый тип.

## Вычисления функций

Это вызов по значению:

1. Слева-направо вычисляются все аргументы функций;
2. Имя функции заменяется на правую сторону определения этой функции;
3. Все формальные параметры функции заменяются на аргументы.

Пример:

```scala
def square(x: Int) = x*x
def sumOfSquares(x: Int, y:Int) = square(x) + square(y)


sumOfSquares(3, 2+2)
sumOfSquares(3,4)
square(3) + square(4)
3*3 + square(4)
9 + square(4)
9 + 4*4
9 + 16
25
```

## Модель замен

Такая модель вычислений называется **Модель замен** (Substitution model).
Выражение приводится к значению.

Эта модель может быть использована для любых выражений, **если у них нет побочных эффектов.**

Такая модель формализована в **λ-calculus** (Лямбда-исчисления). 

## Побочный эффект

Что такое **побочный эффект**?
Предположим, есть выражение:

```
c=0
c++
```

Выражение `c++` нельзя упростить, а для вычисления нужно хранить предыдущее значение. Получается, что есть побочный эффект в виде хранения предыдущего значения, которое некуда подставить по модели замен.


## Цикличность 

- Любое выражение можно привести к значению (за вычислимое количество шагов)?

Не каждое. Контр-пример:

```
def loop: Int = loop

loop
```

Получается, мы должны заменить `loop` на `loop`. Мы привели имя к себе самому. 


## В Scala

Интерпретатор приводит аргументы функции к значениям перед заменой имени функции на функцию. 

Однако, можно применить функцию к неприведённым аргументам.

```scala
sumOfSquares(3, 2+2)
square(3) + square(2+2)
3*3 + square(2+2)
9 + square(2+2)
9 + (2+2) + (2+2)
9 + 4 + (2+2)

...

```

## Вызов по имени и по значению

Теперь нам известно два пути вычисления значений. 

Первый способ называется **вызов по значению**, а второй - **вызов по имени**. 

Оба способа приводят к одинаковым результатам, ведь (важная теорема для лямба-счислений):

- упрощенное выражение состоит из чистых функций и
- оба вычисления конечны.

Вызов по значению имеет преимущество в том, что он вычисляет каждый аргумент функции лишь раз.

Вызов по имени имеет преимуществов в том, что аргументы функции не вычисляются если параметр не использован в самой функции.

Чем меньше шагов упрощения - тем быстрее функция.

Например, для функции:

```
def test(x: Int, y: Int) = x * x

```

При выражении `test(2,3)`

Разницы в количестве шагов нет.

Для выражения `test(3+4, 8)`:

Быстрее будет вызов по значению, ведь 3+4 придётся вызвать лишь раз.

Для выражения `test(7, 2*4)` быстрее будет вызов по имени, ведь Y не используется и его не надо вычислять. 

Для выражения `test(3+4, 2*4)` оба вызова имеют одинаковую скорость:
 
- При вызове по значению мы делаем три шага - выичсление X, вычисление Y и замену функции. - При вызове по имени мы делаем три шага - замену функции, вычисление X и снова вычисление X.




































