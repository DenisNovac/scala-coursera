# 1.5


```scala
/*Вычисляет квадратный корень параметра х*/
def sqrt(x: Double): Double = ...
```

Классический путь - метод Ньютона.

- Задать начальное приближение (estimate) (y=1);
- Улучшать приближение путём взятия среднего значения из y и x/y множество раз.

x = 2

| Estimation        | Quotient           | Mean  |
|:------------- |:-------------|:-----|
| 1     | 2/1 = 2| 1.5 |
|1.5| 2/1.5 = 1.333|1.4167|
|1.4167|2/1.4167=1.4118|1.4142|

## Алгоритмы

Типичный путь построени алгоритма в функциональном языке - это идти шаг за шагом. Сначала берётся маленькая часть, из неё делается функция...

Первая функция, которую мы хотим - это, собственно, итерация

```scala
def sqrtIter(guess: Double, x: Double): Double =
    if (isGoodEnough(guess, x)) guess
    else sqrtIter(improve(guess, x), x)

def isGoodEnough(guess: Double, x: Double) =
	// берем guess и находим квадрат, смотрим на x
	abs(guess * guess - x) < 0.001

def improve(guess: Double, x: Double) =
	(guess + x / guess) / 2

def sqrt(x: Double) = sqrtIter(1.0, x)

print(sqrt(2)) // 1.4142156862745097

```

Возвращаемый тип для рекурсивных функций всегда нужно указывать явно. Это потому что компилятор пытается оптимизировать рекурсии.


Написанная функция `isGoodEnough` плохо работает для слишком маленьких номеров и для слишком больших. 

```
0.001
0.1e-20
1.0e20
1.0e50

```

Это связано с тем, что мы берём ответы по модулю. С другой стороны, число 0.001 не подходит для очень больших номеров. Итерация никогда не остановится потому что просто нет такого значения.

Тест должен быть пропорционален X:

```scala
def isGoodEnough(guess: Double, x: Double) =
    // берем guess и находим квадрат, смотрим на x
    abs(guess * guess - x) / x < 0.001

```



















