# Каррирование

Здесь будет разобрана специальная запись Функций высшего порядка.

Сначала посмотрим на старый пример:

```scala
def sum(f: Int => Int, a: Int, b: Int): Int = {
  @tailrec
  def loop(a: Int, acc: Int): Int = {
    if (a > b) acc
    else loop(a+1, f(a)+acc)
  }
  loop(a, 0)
}

def sumInts(a: Int, b: Int) = sum(x => x, a, b)
def sumCubes(a: Int, b: Int) = sum(x => x * x * x, a, b)
def sumFactorials(a: Int, b: Int) = sum(fact, a ,b)
```

Вопрос. Переменные `a` и `b` передаются из `sumInts` и `sumCubest` в sum неизменными. Можем ли мы избавиться от них и укоротить функцию?

Перепишем функцию следующим образом:

```scala
def sum(f: Int => Int): (Int, Int) => Int = {
  def sumF(a: Int, b: Int): Int =
    if (a > b) 0
    else f(a) + sumF(a + 1, b)
  sumF
}
```

`def sum(f: Int => Int): (Int, Int) => Int = ...` - теперь функция принимает только один параметр `f` функционального типа `Int => Int` и возвращает функциональный тип `(Int, Int) => Int`. Как она это делает?

Она определяет функцию `sumF` в своём теле, которая делает обычные вычисления и эта функция теперь **возвращается**, а не вызывается в `sum`.

Тогда можно переписать функции:

```scala
def sumInts = sum(x => x)
def sumCubes = sum(x => x * x * x)
def sumFact = sum(fact)

sumCubes(1,10)
```

Но можно ли избавиться от приписок `Ints`, `Cubes` и `Fact`? Конечно, ведь можно писать код прямо так:

```scala
sum(cube)(1, 10)
```

Как это работает? Вот так:

- Сначала sum(cube) *применяет* `sum` к `cube` и возвращает функцию, эквивалентную `sumCubes`;
- Затем она применяется к аргументам `(1,10)`.

## Синтаксическй сахар для возвратов функций

Определения функций, которые возвращают функции настолько полезны в функциональном программировании, что в Scala есть **специальный синтаксис** под это дело. Вот это эквивалент выше описанной `sum` со вложенной функцией `sumF`:

```scala
def sum(f: Int => Int): (Int, Int) => Int = {
  def sumF(a: Int, b: Int): Int =
    if (a > b) 0
    else f(a) + sumF(a + 1, b)
  sumF
}
```

```scala
def sum(f: Int => Int)(a: Int, b: Int): Int =
  if (a > b) 0 else f(a) + sum(f)(a + 1, b)

```

Написание двойного списка аргументов позволяет сначала получить функцию `sum(cube)`, а уже затем по контексту передать в неё второй список - `(a,b)`.

## Определение каррирования

`def f = (args1 => (args2 => ... (argsN => E)))`

Стиль определения и совмещения (*application*) функций когда каждая функция маппнута на выражение, являющееся анонимной функцией с одним параметром, называется каррированием.

Ещё раз вернёмся к сигнатуре:

`def sum(f: Int => Int): (Int, Int) => Int = ...`

Вот такой у неё тип:

`(Int => Int) => (Int, Int) => Int`

Сначала она принимает функцию как аргумент (первые скобки), затем возвращает функцию, принимающую два `Int` (вторые скобки) и затем возвращает `Int`. 

Функциональные типы ассоциативны к правой стороне. Например:

`Int => Int => Int` эквивалентен `Int => (Int => Int)`.

## Упражнение

1. Написать функцию `product`, вычисляющую произведение двух параметров на заданном интервале;
2. Написать `factorial` в терминах `product`;
3. Написать более общую функцию, обобщающую `sum` и `product`.

```scala
def main(arguments: Array[String]) = {
  val just_product = product(x => x)(_,_)
  println(just_product(3,5)) // 60

}

def product(f: Int => Int)(a: Int, b: Int): Int = 
  if (a > b) 1 else f(a) * product(f)(a + 1, b)
```

Кстати, мы не прописали в объявлении анонимной функции тип x. Это связано с тем, что компилятор догадался, что мы передаём туда `Int`, когда в `product` мы явно пишем `(f: Int => Int)`.

Теперь создадим факториал в терминах `product`:

```scala
def factorial(n: Int): Int =
    product(x=>x)(1, n)
```

Теперь попробуем создать универсальную функцию, через которую можно вызывать как `sum`, так и `product`.

Эта функция будет параметризована как функцией f и границами, так и одной новой вещью, которая отличалась: "Unit" - значением (0 для суммы и 1 для умножения) и самим действием (умножение или сложение). 

Наконец, напишем общую функцию:

```scala
def main(arguments: Array[String]) = {
    val general_product = general(x => x)(_:Int,_:Int)(1)( (x,y) => x * y)
    val general_sum = general(x => x)(_:Int,_:Int)(0)( (x,y) => x + y)

    println(general_product(2,5)) // 120
    println(general_sum(2,5)) // 14

  }


  /**
   * Эта общая функция принимает f1 - функцию воздействия как и в примерах раньше,
   * параметры a и b как интервалы как в примерах раньше.
   * 
   * u - это "Unit"-значение, для суммы это 0, а для умножения - 1. Его мы 
   * возвращаем когда доходим до точки конца рекурсии.
   * 
   * f2 - это действие над числами. Сумма или умножение, как в примере выше.
   * */
  def general(f1: Int => Int)(a: Int, b: Int)(u: Int)(f2: (Int, Int) => Int ): Int = 
    if (a > b) u else f2( f1(a), general(f1)(a + 1, b)(u)(f2) )
```

Преподаватель назвал её `mapReduce` и организовал аргументы более элегантно:

```scala

val productMap = mapReduce(x => x, (x,y) => x * y, 1)(_: Int,_: Int)

def mapReduce(f: Int => Int, combine: (Int, Int) => Int, zero: Int)(a: Int, b: Int): Int =
    if (a > b) zero
    else combine(f(a), mapReduce(f, combine, zero)(a + 1, b))

```



