# Вычисление и операторы

Мы уже знаем про **Модель замен (Substitution model)**. Теперь нужно выяснить, как она работает с новыми концептами как классы, методы и `this`.

**Вопрос**: *как вычисляется инициализация класса* `new C(e1, ... en)`?
**Ответ**: Аргументы выражения `en` вычисляются как аргументы обычной функции. Результирующее выражение `new` возвращает **значение**.


**Вопрос** : Предположим, есть следующее определение класса:

```scala
class C(x1, ..., xn) { ... def f(y1, ..., yn) = b ... }
```

Где параметры класса - это `x`, класс опеределяет метод `f` с параметрами `y`. 

*Как вычисляется выражение:*

```scala
new C(v1, ..., vn).f(w1, ..., wn)
```

**Ответ**:

Выражение выше можно расписать (через `/` пишутся замены):

```
[w1/y1, ..., wn/yn][v1/x1, ..., vn/xn][new C(v1, ..., vm)/this]b
```

Здесь происходит три замены (у функций была всего одна замена):

- Замена параметров `y` функции `f` на аргументы `w`;
- Замена параметров `x` класса `C` на аргументы `v`;
- Замена ссылки на себя `this` на значение объекта `new C(v1...vn)`

Ссылка на себя здесь как бы возвращает значение нового класса.

Пример:

```scala
new Rational(1,2).numer

// по центру скобки - это замены numer, у него нет параметров
-> [1/x, 2/y] [] [new Rational(1,2)/this]x
= 1



new Raional(1,2).less(new Rational(2,3))
-> [1/x, 2/y][newRational(2,3) / that][new Rational(1,2)/this]
    this.number * that.denom < that.number * this.denom

= new Rational(1, 2).numer * new Rational(2, 3).denom < 
    new Raional(2, 3).numer * new Rational(1, 2).denom

-> 1 * 3 < 2 * 2
-> true
```

## Операторы

Мы работаем с рациональными числами как с нормальными - прибавляем и вычисляем. Но вместо `+` и `-` мы пишем `add` и `sub`. В Scala можно исправить и это.

### Infix Notation (Инфиксная нотация)

Во-первых, каждый метод с параметром в Scala может быть использован как инфиксная нотация (операторы между операндами): `r add s`, `r less s`, `r max s`.

Пример из нашего класса:

```scala
println(y max x)
```

### Relaxed Identifiers

Операторы можно использовать как идентификаторы.

Таким образом, идентификатор может быть:

- **Алфавитнономерным** (начинаться с буквы, содержать буквы или цифры) (классика для ЯП);
- **Символическим** (начинаться с символа оператора и продолжаться символами операторов) (Scala так умеет);
- Подчёркивание `_` считается буквой;
- Алфавитнономерные идентификаторы могут заканчиваться `_`, за которыми следуют символы оператора (можно смешивать типы операторов).

Примеры идентификаторов:

```scala
x1  *   +?%&    vector_++   counter_=
```

Как мы можем применить это к Rational?

```scala
def less(that: Rational) = numer * that.denom < that.numer * denom

// становится:

def < (that: Rational) = numer * that.denom < that.numer * denom

// и так далее:

def + (that: Rational): Rational = 
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom)

def neg: Rational = new Rational(-numer, denom)

// для вычитания прибавляем отрицательное число, меньше повтора кода
def - (that: Rational): Rational = this + that.neg


// Примеры записи:

println(x - y - z) // -79/42
println(y + y) // 70/49  -- 10/7
println(y < x)
```

А как добавить префиксный оператор, чтобы заменить `neg`? Вот так (соглашение использовать `unary`):

```scala
// пробел между - и : обязателен!
def unary_- : Rational = new Rational(-numer, denom)
def - (that: Rational): Rational = this + -that
```

Дело в том, что использование просто `-` считается инфиксным оператором и не может писаться перед объектами (только между).

### Precedence (Старшинство операторов)

Ещё одна вещь, которую нужно узнать. Что, если:

```scala
val x = Rational
val y = Rational

x * x + y * y

// то же, что

(x * x) + (y * y)

```

Как же это происходит, если все операторы переопределены? Старшинство оператора определяется по его первому символу. В порядке возрастания старшинства:

```
буквы
|
^
&
< >
= !
:
+ -
* / %
остальные спецсимволы
```

### Упражнение

Расставить скобки:

```
a + b ^? c ?^ d less a ==> b | c
```

Ответ:

```
((a + b) ^? (c ?^ d) ) less ((a ==> b) | c)
 2           1               3
4                           5
```

